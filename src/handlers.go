package src

import (
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"path"
	"strings"

	"github.com/devfacet/gocmd/v3"
	"github.com/google/go-github/v47/github"
)

const (
	fncInit    = "Init"
	fncReplace = "Replace"
	fncMerge   = "Merge"
	gitOwner   = "github"
	gitRepo    = "gitignore"
)

func InitHandlers() {
	gocmd.HandleFlag(fncInit, func(cmd *gocmd.Cmd, args []string) error {
		language, location, err := handleParams(cmd.FlagArgs(fncInit)[1:])

		if err != nil {
			return err
		}

		if _, err := os.Stat(path.Join(location, ".gitignore")); errors.Is(err, nil) {
			fmt.Printf(".gitignore already exists in %s\n", location)
			return nil
		}

		err = getIgnore(language, location, true, false)

		if err != nil {
			return err
		}

		fmt.Printf("Created .gitignore in %s\n", location)

		return nil
	})

	gocmd.HandleFlag(fncReplace, func(cmd *gocmd.Cmd, args []string) error {
		language, location, err := handleParams(cmd.FlagArgs(fncReplace)[1:])

		if err != nil {
			return err
		}

		if _, err := os.Stat(path.Join(location, ".gitignore")); errors.Is(err, os.ErrNotExist) {
			fmt.Printf(".gitignore does not exist in %s\n", location)
			return nil
		}

		err = getIgnore(language, location, false, false)

		if err != nil {
			return err
		}

		fmt.Printf("Replaced .gitignore in %s\n", location)

		return nil
	})

	gocmd.HandleFlag(fncMerge, func(cmd *gocmd.Cmd, args []string) error {
		language, location, err := handleParams(cmd.FlagArgs(fncMerge)[1:])

		if err != nil {
			return err
		}

		if _, err := os.Stat(path.Join(location, ".gitignore")); errors.Is(err, os.ErrNotExist) {
			fmt.Printf(".gitignore does not exist in %s\n", location)
			return nil
		}

		err = getIgnore(language, location, false, true)

		if err != nil {
			return err
		}

		fmt.Printf("Merged .gitignore in %s\n", location)

		return nil
	})
}

func handleParams(params []string) (string, string, error) {
	if len(params) == 0 {
		return "", "", errors.New("no arguments supplied")
	}

	if len(params) == 1 {
		params = append(params, ".")
	}

	return params[0], params[1], nil
}

func getIgnore(language string, location string, isNew bool, isMerge bool) error {
	client := github.NewClient(nil)
	ctx := context.Background()
	options := &github.RepositoryContentGetOptions{}

	_, directoryContent, _, err := client.Repositories.GetContents(ctx, gitOwner, gitRepo, "/", options)

	if err != nil {
		return err
	}

	var url string

	for _, file := range directoryContent {
		if !strings.EqualFold(strings.Split(*file.Name, ".")[0], language) {
			continue
		}

		url = file.GetPath()

		break
	}

	if url == "" {
		return fmt.Errorf("could not find .gitignore for %s", language)
	}

	reader, response, err := client.Repositories.DownloadContents(ctx, gitOwner, gitRepo, url, options)

	if err != nil {
		return err
	}

	if response.StatusCode != 200 {
		return fmt.Errorf("error downloading .gitignore for %s", language)
	}

	defer reader.Close()

	bytes, err := io.ReadAll(reader)

	if err != nil {
		return err
	}

	var file *os.File
	fullPath := path.Join(location, ".gitignore")

	if isMerge {
		file, err = os.OpenFile(fullPath, os.O_RDWR|os.O_APPEND, 0755)

		if err != nil {
			return err
		}

		defer file.Close()

		_, err = file.Write(bytes)

		if err != nil {
			return err
		}

		return nil
	}

	if isNew {
		bytes = append([]byte("# Generated by ignoreinit (https://github.com/loupeznik/ignoreinit) \n\n"), bytes...)

		file, err = os.Create(fullPath)
	} else {
		file, err = os.OpenFile(fullPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	}

	if err != nil {
		return err
	}

	defer file.Close()

	_, err = file.Write(bytes)

	if err != nil {
		return err
	}

	return nil
}
